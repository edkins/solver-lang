from .z3core import *
from .z3types import *
from .z3consts import *
from .z3printer import *
from . import z3core as z3core
from collections.abc import Generator
from typing import Any

Z3_DEBUG = __debug__

def z3_debug(): ...
def enable_trace(msg) -> None: ...
def disable_trace(msg) -> None: ...
def get_version_string(): ...
def get_version(): ...
def get_full_version(): ...
def open_log(fname) -> None: ...
def append_log(s) -> None: ...
def to_symbol(s, ctx: Any | None = ...): ...
def z3_error_handler(c, e) -> None: ...

class Context:
    ctx: Any
    eh: Any
    def __init__(self, *args, **kws) -> None: ...
    def __del__(self) -> None: ...
    def ref(self): ...
    def interrupt(self) -> None: ...

def main_ctx(): ...
def get_ctx(ctx): ...
def set_param(*args, **kws) -> None: ...
def reset_params() -> None: ...
def set_option(*args, **kws): ...
def get_param(name): ...

class Z3PPObject:
    def use_pp(self): ...

class AstRef(Z3PPObject):
    ast: Any
    ctx: Any
    def __init__(self, ast, ctx: Any | None = ...) -> None: ...
    def __del__(self) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __eq__(self, other): ...
    def __hash__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def sexpr(self): ...
    def as_ast(self): ...
    def get_id(self): ...
    def ctx_ref(self): ...
    def eq(self, other): ...
    def translate(self, target): ...
    def __copy__(self): ...
    def hash(self): ...

def is_ast(a): ...
def eq(a, b): ...

class SortRef(AstRef):
    def as_ast(self): ...
    def get_id(self): ...
    def kind(self): ...
    def subsort(self, other): ...
    def cast(self, val): ...
    def name(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...

def is_sort(s): ...
def DeclareSort(name, ctx: Any | None = ...): ...

class FuncDeclRef(AstRef):
    def as_ast(self): ...
    def get_id(self): ...
    def as_func_decl(self): ...
    def name(self): ...
    def arity(self): ...
    def domain(self, i): ...
    def range(self): ...
    def kind(self): ...
    def params(self): ...
    def __call__(self, *args): ...

def is_func_decl(a): ...
def Function(name, *sig): ...
def FreshFunction(*sig): ...
def RecFunction(name, *sig): ...
def RecAddDefinition(f, args, body) -> None: ...

class ExprRef(AstRef):
    def as_ast(self): ...
    def get_id(self): ...
    def sort(self): ...
    def sort_kind(self): ...
    def __eq__(self, other): ...
    def __hash__(self): ...
    def __ne__(self, other): ...
    def params(self): ...
    def decl(self): ...
    def num_args(self): ...
    def arg(self, idx): ...
    def children(self): ...

def is_expr(a): ...
def is_app(a): ...
def is_const(a): ...
def is_var(a): ...
def get_var_index(a): ...
def is_app_of(a, k): ...
def If(a, b, c, ctx: Any | None = ...): ...
def Distinct(*args): ...
def Const(name, sort): ...
def Consts(names, sort): ...
def FreshConst(sort, prefix: str = ...): ...
def Var(idx, s): ...
def RealVar(idx, ctx: Any | None = ...): ...
def RealVarVector(n, ctx: Any | None = ...): ...

class BoolSortRef(SortRef):
    def cast(self, val): ...
    def subsort(self, other): ...
    def is_int(self): ...
    def is_bool(self): ...

class BoolRef(ExprRef):
    def sort(self): ...
    def __rmul__(self, other): ...
    def __mul__(self, other): ...

def is_bool(a): ...
def is_true(a): ...
def is_false(a): ...
def is_and(a): ...
def is_or(a): ...
def is_implies(a): ...
def is_not(a): ...
def is_eq(a): ...
def is_distinct(a): ...
def BoolSort(ctx: Any | None = ...): ...
def BoolVal(val, ctx: Any | None = ...): ...
def Bool(name, ctx: Any | None = ...): ...
def Bools(names, ctx: Any | None = ...): ...
def BoolVector(prefix, sz, ctx: Any | None = ...): ...
def FreshBool(prefix: str = ..., ctx: Any | None = ...): ...
def Implies(a, b, ctx: Any | None = ...): ...
def Xor(a, b, ctx: Any | None = ...): ...
def Not(a, ctx: Any | None = ...): ...
def mk_not(a): ...
def And(*args): ...
def Or(*args): ...

class PatternRef(ExprRef):
    def as_ast(self): ...
    def get_id(self): ...

def is_pattern(a): ...
def MultiPattern(*args): ...

class QuantifierRef(BoolRef):
    def as_ast(self): ...
    def get_id(self): ...
    def sort(self): ...
    def is_forall(self): ...
    def is_exists(self): ...
    def is_lambda(self): ...
    def __getitem__(self, arg): ...
    def weight(self): ...
    def num_patterns(self): ...
    def pattern(self, idx): ...
    def num_no_patterns(self): ...
    def no_pattern(self, idx): ...
    def body(self): ...
    def num_vars(self): ...
    def var_name(self, idx): ...
    def var_sort(self, idx): ...
    def children(self): ...

def is_quantifier(a): ...
def ForAll(vs, body, weight: int = ..., qid: str = ..., skid: str = ..., patterns=..., no_patterns=...): ...
def Exists(vs, body, weight: int = ..., qid: str = ..., skid: str = ..., patterns=..., no_patterns=...): ...
def Lambda(vs, body): ...

class ArithSortRef(SortRef):
    def is_real(self): ...
    def is_int(self): ...
    def subsort(self, other): ...
    def cast(self, val): ...

def is_arith_sort(s): ...

class ArithRef(ExprRef):
    def sort(self): ...
    def is_int(self): ...
    def is_real(self): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __pow__(self, other): ...
    def __rpow__(self, other): ...
    def __div__(self, other): ...
    def __truediv__(self, other): ...
    def __rdiv__(self, other): ...
    def __rtruediv__(self, other): ...
    def __mod__(self, other): ...
    def __rmod__(self, other): ...
    def __neg__(self): ...
    def __pos__(self): ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...

def is_arith(a): ...
def is_int(a): ...
def is_real(a): ...
def is_int_value(a): ...
def is_rational_value(a): ...
def is_algebraic_value(a): ...
def is_add(a): ...
def is_mul(a): ...
def is_sub(a): ...
def is_div(a): ...
def is_idiv(a): ...
def is_mod(a): ...
def is_le(a): ...
def is_lt(a): ...
def is_ge(a): ...
def is_gt(a): ...
def is_is_int(a): ...
def is_to_real(a): ...
def is_to_int(a): ...

class IntNumRef(ArithRef):
    def as_long(self): ...
    def as_string(self): ...
    def as_binary_string(self): ...

class RatNumRef(ArithRef):
    def numerator(self): ...
    def denominator(self): ...
    def numerator_as_long(self): ...
    def denominator_as_long(self): ...
    def is_int(self): ...
    def is_real(self): ...
    def is_int_value(self): ...
    def as_long(self): ...
    def as_decimal(self, prec): ...
    def as_string(self): ...
    def as_fraction(self): ...

class AlgebraicNumRef(ArithRef):
    def approx(self, precision: int = ...): ...
    def as_decimal(self, prec): ...
    def poly(self): ...
    def index(self): ...

def IntSort(ctx: Any | None = ...): ...
def RealSort(ctx: Any | None = ...): ...
def IntVal(val, ctx: Any | None = ...): ...
def RealVal(val, ctx: Any | None = ...): ...
def RatVal(a, b, ctx: Any | None = ...): ...
def Q(a, b, ctx: Any | None = ...): ...
def Int(name, ctx: Any | None = ...): ...
def Ints(names, ctx: Any | None = ...): ...
def IntVector(prefix, sz, ctx: Any | None = ...): ...
def FreshInt(prefix: str = ..., ctx: Any | None = ...): ...
def Real(name, ctx: Any | None = ...): ...
def Reals(names, ctx: Any | None = ...): ...
def RealVector(prefix, sz, ctx: Any | None = ...): ...
def FreshReal(prefix: str = ..., ctx: Any | None = ...): ...
def ToReal(a): ...
def ToInt(a): ...
def IsInt(a): ...
def Sqrt(a, ctx: Any | None = ...): ...
def Cbrt(a, ctx: Any | None = ...): ...

class BitVecSortRef(SortRef):
    def size(self): ...
    def subsort(self, other): ...
    def cast(self, val): ...

def is_bv_sort(s): ...

class BitVecRef(ExprRef):
    def sort(self): ...
    def size(self): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __or__(self, other): ...
    def __ror__(self, other): ...
    def __and__(self, other): ...
    def __rand__(self, other): ...
    def __xor__(self, other): ...
    def __rxor__(self, other): ...
    def __pos__(self): ...
    def __neg__(self): ...
    def __invert__(self): ...
    def __div__(self, other): ...
    def __truediv__(self, other): ...
    def __rdiv__(self, other): ...
    def __rtruediv__(self, other): ...
    def __mod__(self, other): ...
    def __rmod__(self, other): ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    def __rshift__(self, other): ...
    def __lshift__(self, other): ...
    def __rrshift__(self, other): ...
    def __rlshift__(self, other): ...

class BitVecNumRef(BitVecRef):
    def as_long(self): ...
    def as_signed_long(self): ...
    def as_string(self): ...
    def as_binary_string(self): ...

def is_bv(a): ...
def is_bv_value(a): ...
def BV2Int(a, is_signed: bool = ...): ...
def Int2BV(a, num_bits): ...
def BitVecSort(sz, ctx: Any | None = ...): ...
def BitVecVal(val, bv, ctx: Any | None = ...): ...
def BitVec(name, bv, ctx: Any | None = ...): ...
def BitVecs(names, bv, ctx: Any | None = ...): ...
def Concat(*args): ...
def Extract(high, low, a): ...
def ULE(a, b): ...
def ULT(a, b): ...
def UGE(a, b): ...
def UGT(a, b): ...
def UDiv(a, b): ...
def URem(a, b): ...
def SRem(a, b): ...
def LShR(a, b): ...
def RotateLeft(a, b): ...
def RotateRight(a, b): ...
def SignExt(n, a): ...
def ZeroExt(n, a): ...
def RepeatBitVec(n, a): ...
def BVRedAnd(a): ...
def BVRedOr(a): ...
def BVAddNoOverflow(a, b, signed): ...
def BVAddNoUnderflow(a, b): ...
def BVSubNoOverflow(a, b): ...
def BVSubNoUnderflow(a, b, signed): ...
def BVSDivNoOverflow(a, b): ...
def BVSNegNoOverflow(a): ...
def BVMulNoOverflow(a, b, signed): ...
def BVMulNoUnderflow(a, b): ...

class ArraySortRef(SortRef):
    def domain(self): ...
    def range(self): ...

class ArrayRef(ExprRef):
    def sort(self): ...
    def domain(self): ...
    def range(self): ...
    def __getitem__(self, arg): ...
    def default(self): ...

def is_array_sort(a): ...
def is_array(a): ...
def is_const_array(a): ...
def is_K(a): ...
def is_map(a): ...
def is_default(a): ...
def get_map_func(a): ...
def ArraySort(*sig): ...
#def Array(name, dom, rng): ...
def Update(a, i, v): ...
def Default(a): ...
def Store(a, i, v): ...
def Select(a, i): ...
def Map(f, *args): ...
def K(dom, v): ...
def Ext(a, b): ...
def SetHasSize(a, k): ...
def is_select(a): ...
def is_store(a): ...
def SetSort(s): ...
def EmptySet(s): ...
def FullSet(s): ...
def SetUnion(*args): ...
def SetIntersect(*args): ...
def SetAdd(s, e): ...
def SetDel(s, e): ...
def SetComplement(s): ...
def SetDifference(a, b): ...
def IsMember(e, s): ...
def IsSubset(a, b): ...

class Datatype:
    ctx: Any
    name: Any
    constructors: Any
    def __init__(self, name, ctx: Any | None = ...) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def declare_core(self, name, rec_name, *args) -> None: ...
    def declare(self, name, *args): ...
    def create(self): ...

class ScopedConstructor:
    c: Any
    ctx: Any
    def __init__(self, c, ctx) -> None: ...
    def __del__(self) -> None: ...

class ScopedConstructorList:
    c: Any
    ctx: Any
    def __init__(self, c, ctx) -> None: ...
    def __del__(self) -> None: ...

def CreateDatatypes(*ds): ...

class DatatypeSortRef(SortRef):
    def num_constructors(self): ...
    def constructor(self, idx): ...
    def recognizer(self, idx): ...
    def accessor(self, i, j): ...

class DatatypeRef(ExprRef):
    def sort(self): ...

def TupleSort(name, sorts, ctx: Any | None = ...): ...
def DisjointSum(name, sorts, ctx: Any | None = ...): ...
def EnumSort(name, values, ctx: Any | None = ...): ...

class ParamsRef:
    ctx: Any
    params: Any
    def __init__(self, ctx: Any | None = ..., params: Any | None = ...) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def set(self, name, val) -> None: ...
    def validate(self, ds) -> None: ...

def args2params(arguments, keywords, ctx: Any | None = ...): ...

class ParamDescrsRef:
    ctx: Any
    descr: Any
    def __init__(self, descr, ctx: Any | None = ...) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def size(self): ...
    def __len__(self): ...
    def get_name(self, i): ...
    def get_kind(self, n): ...
    def get_documentation(self, n): ...
    def __getitem__(self, arg): ...

class Goal(Z3PPObject):
    ctx: Any
    goal: Any
    def __init__(self, models: bool = ..., unsat_cores: bool = ..., proofs: bool = ..., ctx: Any | None = ..., goal: Any | None = ...) -> None: ...
    def __del__(self) -> None: ...
    def depth(self): ...
    def inconsistent(self): ...
    def prec(self): ...
    def precision(self): ...
    def size(self): ...
    def __len__(self): ...
    def get(self, i): ...
    def __getitem__(self, arg): ...
    def assert_exprs(self, *args) -> None: ...
    def append(self, *args) -> None: ...
    def insert(self, *args) -> None: ...
    def add(self, *args) -> None: ...
    def convert_model(self, model): ...
    def sexpr(self): ...
    def dimacs(self, include_names: bool = ...): ...
    def translate(self, target): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo=...): ...
    def simplify(self, *arguments, **keywords): ...
    def as_expr(self): ...

class AstVector(Z3PPObject):
    vector: Any
    ctx: Any
    def __init__(self, v: Any | None = ..., ctx: Any | None = ...) -> None: ...
    def __del__(self) -> None: ...
    def __len__(self): ...
    def __getitem__(self, i): ...
    def __setitem__(self, i, v) -> None: ...
    def push(self, v) -> None: ...
    def resize(self, sz) -> None: ...
    def __contains__(self, item): ...
    def translate(self, other_ctx): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo=...): ...
    def sexpr(self): ...

class AstMap:
    map: Any
    ctx: Any
    def __init__(self, m: Any | None = ..., ctx: Any | None = ...) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def __len__(self): ...
    def __contains__(self, key): ...
    def __getitem__(self, key): ...
    def __setitem__(self, k, v) -> None: ...
    def erase(self, k) -> None: ...
    def reset(self) -> None: ...
    def keys(self): ...

class FuncEntry:
    entry: Any
    ctx: Any
    def __init__(self, entry, ctx) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def num_args(self): ...
    def arg_value(self, idx): ...
    def value(self): ...
    def as_list(self): ...

class FuncInterp(Z3PPObject):
    f: Any
    ctx: Any
    def __init__(self, f, ctx) -> None: ...
    def __del__(self) -> None: ...
    def else_value(self): ...
    def num_entries(self): ...
    def arity(self): ...
    def entry(self, idx): ...
    def translate(self, other_ctx): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo=...): ...
    def as_list(self): ...

class ModelRef(Z3PPObject):
    model: Any
    ctx: Any
    def __init__(self, m, ctx) -> None: ...
    def __del__(self) -> None: ...
    def sexpr(self): ...
    def eval(self, t, model_completion: bool = ...): ...
    def evaluate(self, t, model_completion: bool = ...): ...
    def __len__(self): ...
    def get_interp(self, decl): ...
    def num_sorts(self): ...
    def get_sort(self, idx): ...
    def sorts(self): ...
    def get_universe(self, s): ...
    def __getitem__(self, idx): ...
    def decls(self): ...
    def update_value(self, x, value) -> None: ...
    def translate(self, target): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo=...): ...

#def Model(ctx: Any | None = ...): ...
def is_as_array(n): ...
def get_as_array_func(n): ...

class Statistics:
    stats: Any
    ctx: Any
    def __init__(self, stats, ctx) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def __len__(self): ...
    def __getitem__(self, idx): ...
    def keys(self): ...
    def get_key_value(self, key): ...
    def __getattr__(self, name): ...

class CheckSatResult:
    r: Any
    def __init__(self, r) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...

sat: Any
unsat: Any
unknown: Any

class Solver(Z3PPObject):
    ctx: Any
    backtrack_level: int
    solver: Any
    def __init__(self, solver: Any | None = ..., ctx: Any | None = ..., logFile: Any | None = ...) -> None: ...
    def __del__(self) -> None: ...
    def set(self, *args, **keys) -> None: ...
    def push(self) -> None: ...
    def pop(self, num: int = ...) -> None: ...
    def num_scopes(self): ...
    def reset(self) -> None: ...
    def assert_exprs(self, *args) -> None: ...
    def add(self, *args) -> None: ...
    def __iadd__(self, fml): ...
    def append(self, *args) -> None: ...
    def insert(self, *args) -> None: ...
    def assert_and_track(self, a, p) -> None: ...
    def check(self, *assumptions): ...
    def model(self): ...
    def import_model_converter(self, other) -> None: ...
    def unsat_core(self): ...
    def consequences(self, assumptions, variables): ...
    def from_file(self, filename) -> None: ...
    def from_string(self, s) -> None: ...
    cube_vs: Any
    def cube(self, vars: Any | None = ...) -> Generator[Any, None, None]: ...
    def cube_vars(self): ...
    def proof(self): ...
    def assertions(self): ...
    def units(self): ...
    def non_units(self): ...
    def trail_levels(self): ...
    def trail(self): ...
    def statistics(self): ...
    def reason_unknown(self): ...
    def help(self) -> None: ...
    def param_descrs(self): ...
    def translate(self, target): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo=...): ...
    def sexpr(self): ...
    def dimacs(self, include_names: bool = ...): ...
    def to_smt2(self): ...

def SolverFor(logic, ctx: Any | None = ..., logFile: Any | None = ...): ...
def SimpleSolver(ctx: Any | None = ..., logFile: Any | None = ...): ...

class Fixedpoint(Z3PPObject):
    ctx: Any
    fixedpoint: Any
    vars: Any
    def __init__(self, fixedpoint: Any | None = ..., ctx: Any | None = ...) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def set(self, *args, **keys) -> None: ...
    def help(self) -> None: ...
    def param_descrs(self): ...
    def assert_exprs(self, *args) -> None: ...
    def add(self, *args) -> None: ...
    def __iadd__(self, fml): ...
    def append(self, *args) -> None: ...
    def insert(self, *args) -> None: ...
    def add_rule(self, head, body: Any | None = ..., name: Any | None = ...) -> None: ...
    def rule(self, head, body: Any | None = ..., name: Any | None = ...) -> None: ...
    def fact(self, head, name: Any | None = ...) -> None: ...
    def query(self, *query): ...
    def query_from_lvl(self, lvl, *query): ...
    def update_rule(self, head, body, name) -> None: ...
    def get_answer(self): ...
    def get_ground_sat_answer(self): ...
    def get_rules_along_trace(self): ...
    def get_rule_names_along_trace(self): ...
    def get_num_levels(self, predicate): ...
    def get_cover_delta(self, level, predicate): ...
    def add_cover(self, level, predicate, property) -> None: ...
    def register_relation(self, *relations) -> None: ...
    def set_predicate_representation(self, f, *representations) -> None: ...
    def parse_string(self, s): ...
    def parse_file(self, f): ...
    def get_rules(self): ...
    def get_assertions(self): ...
    def sexpr(self): ...
    def to_string(self, queries): ...
    def statistics(self): ...
    def reason_unknown(self): ...
    def declare_var(self, *vars) -> None: ...
    def abstract(self, fml, is_forall: bool = ...): ...

class FiniteDomainSortRef(SortRef):
    def size(self): ...

def FiniteDomainSort(name, sz, ctx: Any | None = ...): ...
def is_finite_domain_sort(s): ...

class FiniteDomainRef(ExprRef):
    def sort(self): ...
    def as_string(self): ...

def is_finite_domain(a): ...

class FiniteDomainNumRef(FiniteDomainRef):
    def as_long(self): ...
    def as_string(self): ...

def FiniteDomainVal(val, sort, ctx: Any | None = ...): ...
def is_finite_domain_value(a): ...

class OptimizeObjective:
    def __init__(self, opt, value, is_max) -> None: ...
    def lower(self): ...
    def upper(self): ...
    def lower_values(self): ...
    def upper_values(self): ...
    def value(self): ...

class Optimize(Z3PPObject):
    ctx: Any
    optimize: Any
    def __init__(self, ctx: Any | None = ...) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def set(self, *args, **keys) -> None: ...
    def help(self) -> None: ...
    def param_descrs(self): ...
    def assert_exprs(self, *args) -> None: ...
    def add(self, *args) -> None: ...
    def __iadd__(self, fml): ...
    def assert_and_track(self, a, p) -> None: ...
    def add_soft(self, arg, weight: str = ..., id: Any | None = ...): ...
    def maximize(self, arg): ...
    def minimize(self, arg): ...
    def push(self) -> None: ...
    def pop(self) -> None: ...
    def check(self, *assumptions): ...
    def reason_unknown(self): ...
    def model(self): ...
    def unsat_core(self): ...
    def lower(self, obj): ...
    def upper(self, obj): ...
    def lower_values(self, obj): ...
    def upper_values(self, obj): ...
    def from_file(self, filename) -> None: ...
    def from_string(self, s) -> None: ...
    def assertions(self): ...
    def objectives(self): ...
    def sexpr(self): ...
    def statistics(self): ...
    def set_on_model(self, on_model) -> None: ...

class ApplyResult(Z3PPObject):
    result: Any
    ctx: Any
    def __init__(self, result, ctx) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def __len__(self): ...
    def __getitem__(self, idx): ...
    def sexpr(self): ...
    def as_expr(self): ...

class Tactic:
    ctx: Any
    tactic: Any
    def __init__(self, tactic, ctx: Any | None = ...) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def solver(self, logFile: Any | None = ...): ...
    def apply(self, goal, *arguments, **keywords): ...
    def __call__(self, goal, *arguments, **keywords): ...
    def help(self) -> None: ...
    def param_descrs(self): ...

def AndThen(*ts, **ks): ...
def Then(*ts, **ks): ...
def OrElse(*ts, **ks): ...
def ParOr(*ts, **ks): ...
def ParThen(t1, t2, ctx: Any | None = ...): ...
def ParAndThen(t1, t2, ctx: Any | None = ...): ...
def With(t, *args, **keys): ...
def WithParams(t, p): ...
def Repeat(t, max: int = ..., ctx: Any | None = ...): ...
def TryFor(t, ms, ctx: Any | None = ...): ...
def tactics(ctx: Any | None = ...): ...
def tactic_description(name, ctx: Any | None = ...): ...
def describe_tactics() -> None: ...

class Probe:
    ctx: Any
    probe: Any
    def __init__(self, probe, ctx: Any | None = ...) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self) -> None: ...
    def __lt__(self, other): ...
    def __gt__(self, other): ...
    def __le__(self, other): ...
    def __ge__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __call__(self, goal): ...

def is_probe(p): ...
def probes(ctx: Any | None = ...): ...
def probe_description(name, ctx: Any | None = ...): ...
def describe_probes() -> None: ...
def FailIf(p, ctx: Any | None = ...): ...
def When(p, t, ctx: Any | None = ...): ...
def Cond(p, t1, t2, ctx: Any | None = ...): ...
def simplify(a, *arguments, **keywords): ...
def help_simplify() -> None: ...
def simplify_param_descrs(): ...
def substitute(t, *m): ...
def substitute_vars(t, *m): ...
def Sum(*args): ...
def Product(*args): ...
def AtMost(*args): ...
def AtLeast(*args): ...
def PbLe(args, k): ...
def PbGe(args, k): ...
def PbEq(args, k, ctx: Any | None = ...): ...
def solve(*args, **keywords) -> None: ...
def solve_using(s, *args, **keywords) -> None: ...
def prove(claim, show: bool = ..., **keywords) -> None: ...
def parse_smt2_string(s, sorts=..., decls=..., ctx: Any | None = ...): ...
def parse_smt2_file(f, sorts=..., decls=..., ctx: Any | None = ...): ...
def get_default_rounding_mode(ctx: Any | None = ...): ...
def set_default_rounding_mode(rm, ctx: Any | None = ...) -> None: ...
def get_default_fp_sort(ctx: Any | None = ...): ...
def set_default_fp_sort(ebits, sbits, ctx: Any | None = ...) -> None: ...

class FPSortRef(SortRef):
    def ebits(self): ...
    def sbits(self): ...
    def cast(self, val): ...

def Float16(ctx: Any | None = ...): ...
def FloatHalf(ctx: Any | None = ...): ...
def Float32(ctx: Any | None = ...): ...
def FloatSingle(ctx: Any | None = ...): ...
def Float64(ctx: Any | None = ...): ...
def FloatDouble(ctx: Any | None = ...): ...
def Float128(ctx: Any | None = ...): ...
def FloatQuadruple(ctx: Any | None = ...): ...

class FPRMSortRef(SortRef): ...

def is_fp_sort(s): ...
def is_fprm_sort(s): ...

class FPRef(ExprRef):
    def sort(self): ...
    def ebits(self): ...
    def sbits(self): ...
    def as_string(self): ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __pos__(self): ...
    def __neg__(self): ...
    def __div__(self, other): ...
    def __rdiv__(self, other): ...
    def __truediv__(self, other): ...
    def __rtruediv__(self, other): ...
    def __mod__(self, other): ...
    def __rmod__(self, other): ...

class FPRMRef(ExprRef):
    def as_string(self): ...

def RoundNearestTiesToEven(ctx: Any | None = ...): ...
def RNE(ctx: Any | None = ...): ...
def RoundNearestTiesToAway(ctx: Any | None = ...): ...
def RNA(ctx: Any | None = ...): ...
def RoundTowardPositive(ctx: Any | None = ...): ...
def RTP(ctx: Any | None = ...): ...
def RoundTowardNegative(ctx: Any | None = ...): ...
def RTN(ctx: Any | None = ...): ...
def RoundTowardZero(ctx: Any | None = ...): ...
def RTZ(ctx: Any | None = ...): ...
def is_fprm(a): ...
def is_fprm_value(a): ...

class FPNumRef(FPRef):
    def sign(self): ...
    def sign_as_bv(self): ...
    def significand(self): ...
    def significand_as_long(self): ...
    def significand_as_bv(self): ...
    def exponent(self, biased: bool = ...): ...
    def exponent_as_long(self, biased: bool = ...): ...
    def exponent_as_bv(self, biased: bool = ...): ...
    def isNaN(self): ...
    def isInf(self): ...
    def isZero(self): ...
    def isNormal(self): ...
    def isSubnormal(self): ...
    def isPositive(self): ...
    def isNegative(self): ...
    def as_string(self): ...

def is_fp(a): ...
def is_fp_value(a): ...
def FPSort(ebits, sbits, ctx: Any | None = ...): ...
def fpNaN(s): ...
def fpPlusInfinity(s): ...
def fpMinusInfinity(s): ...
def fpInfinity(s, negative): ...
def fpPlusZero(s): ...
def fpMinusZero(s): ...
def fpZero(s, negative): ...
def FPVal(sig, exp: Any | None = ..., fps: Any | None = ..., ctx: Any | None = ...): ...
def FP(name, fpsort, ctx: Any | None = ...): ...
def FPs(names, fpsort, ctx: Any | None = ...): ...
def fpAbs(a, ctx: Any | None = ...): ...
def fpNeg(a, ctx: Any | None = ...): ...
def fpAdd(rm, a, b, ctx: Any | None = ...): ...
def fpSub(rm, a, b, ctx: Any | None = ...): ...
def fpMul(rm, a, b, ctx: Any | None = ...): ...
def fpDiv(rm, a, b, ctx: Any | None = ...): ...
def fpRem(a, b, ctx: Any | None = ...): ...
def fpMin(a, b, ctx: Any | None = ...): ...
def fpMax(a, b, ctx: Any | None = ...): ...
def fpFMA(rm, a, b, c, ctx: Any | None = ...): ...
def fpSqrt(rm, a, ctx: Any | None = ...): ...
def fpRoundToIntegral(rm, a, ctx: Any | None = ...): ...
def fpIsNaN(a, ctx: Any | None = ...): ...
def fpIsInf(a, ctx: Any | None = ...): ...
def fpIsZero(a, ctx: Any | None = ...): ...
def fpIsNormal(a, ctx: Any | None = ...): ...
def fpIsSubnormal(a, ctx: Any | None = ...): ...
def fpIsNegative(a, ctx: Any | None = ...): ...
def fpIsPositive(a, ctx: Any | None = ...): ...
def fpLT(a, b, ctx: Any | None = ...): ...
def fpLEQ(a, b, ctx: Any | None = ...): ...
def fpGT(a, b, ctx: Any | None = ...): ...
def fpGEQ(a, b, ctx: Any | None = ...): ...
def fpEQ(a, b, ctx: Any | None = ...): ...
def fpNEQ(a, b, ctx: Any | None = ...): ...
def fpFP(sgn, exp, sig, ctx: Any | None = ...): ...
def fpToFP(a1, a2: Any | None = ..., a3: Any | None = ..., ctx: Any | None = ...): ...
def fpBVToFP(v, sort, ctx: Any | None = ...): ...
def fpFPToFP(rm, v, sort, ctx: Any | None = ...): ...
def fpRealToFP(rm, v, sort, ctx: Any | None = ...): ...
def fpSignedToFP(rm, v, sort, ctx: Any | None = ...): ...
def fpUnsignedToFP(rm, v, sort, ctx: Any | None = ...): ...
def fpToFPUnsigned(rm, x, s, ctx: Any | None = ...): ...
def fpToSBV(rm, x, s, ctx: Any | None = ...): ...
def fpToUBV(rm, x, s, ctx: Any | None = ...): ...
def fpToReal(x, ctx: Any | None = ...): ...
def fpToIEEEBV(x, ctx: Any | None = ...): ...

class SeqSortRef(SortRef):
    def is_string(self): ...
    def basis(self): ...

class CharSortRef(SortRef): ...

def StringSort(ctx: Any | None = ...): ...
def CharSort(ctx: Any | None = ...): ...
def SeqSort(s): ...

class SeqRef(ExprRef):
    def sort(self): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __getitem__(self, i): ...
    def at(self, i): ...
    def is_string(self): ...
    def is_string_value(self): ...
    def as_string(self): ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...

def is_seq(a): ...
def is_string(a): ...
def is_string_value(a): ...
def StringVal(s, ctx: Any | None = ...): ...
def String(name, ctx: Any | None = ...): ...
def Strings(names, ctx: Any | None = ...): ...
def SubString(s, offset, length): ...
def SubSeq(s, offset, length): ...
def Empty(s): ...
def Full(s): ...
def Unit(a): ...
def PrefixOf(a, b): ...
def SuffixOf(a, b): ...
def Contains(a, b): ...
def Replace(s, src, dst): ...
def IndexOf(s, substr, offset: Any | None = ...): ...
def LastIndexOf(s, substr): ...
def Length(s): ...
def StrToInt(s): ...
def IntToStr(s): ...
def Re(s, ctx: Any | None = ...): ...

class ReSortRef(SortRef):
    def basis(self): ...

def ReSort(s): ...

class ReRef(ExprRef):
    def __add__(self, other): ...

def is_re(s): ...
def InRe(s, re): ...
#def Union(*args): ...
def Intersect(*args): ...
def Plus(re): ...
def Option(re): ...
def Complement(re): ...
def Star(re): ...
def Loop(re, lo, hi: int = ...): ...
def Range(lo, hi, ctx: Any | None = ...): ...
def AllChar(regex_sort, ctx: Any | None = ...): ...
def PartialOrder(a, index): ...
def LinearOrder(a, index): ...
def TreeOrder(a, index): ...
def PiecewiseLinearOrder(a, index): ...
def TransitiveClosure(f): ...

class PropClosures:
    bases: Any
    lock: Any
    def __init__(self) -> None: ...
    def set_threaded(self) -> None: ...
    def get(self, ctx): ...
    def set(self, ctx, r) -> None: ...
    def insert(self, r): ...

def ensure_prop_closures() -> None: ...
def user_prop_push(ctx) -> None: ...
def user_prop_pop(ctx, num_scopes) -> None: ...
def user_prop_fresh(id, ctx): ...
def user_prop_fixed(ctx, cb, id, value) -> None: ...
def user_prop_final(ctx, cb) -> None: ...
def user_prop_eq(ctx, cb, x, y) -> None: ...
def user_prop_diseq(ctx, cb, x, y) -> None: ...

class UserPropagateBase:
    solver: Any
    cb: Any
    id: Any
    fixed: Any
    final: Any
    eq: Any
    diseq: Any
    def __init__(self, s, ctx: Any | None = ...) -> None: ...
    def __del__(self) -> None: ...
    def ctx(self): ...
    def ctx_ref(self): ...
    def add_fixed(self, fixed) -> None: ...
    def add_final(self, final) -> None: ...
    def add_eq(self, eq) -> None: ...
    def add_diseq(self, diseq) -> None: ...
    def push(self) -> None: ...
    def pop(self, num_scopes) -> None: ...
    def fresh(self) -> None: ...
    def add(self, e): ...
    def propagate(self, e, ids, eqs=...) -> None: ...
    def conflict(self, ids) -> None: ...
